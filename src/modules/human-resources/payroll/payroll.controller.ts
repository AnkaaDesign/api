// payroll.controller.ts
// Clean implementation - Regular CRUD + Live calculation endpoints

import {
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  ParseIntPipe,
  ParseUUIDPipe,
  Post,
  Put,
  Query,
  UseGuards,
} from '@nestjs/common';
import { PayrollService } from './payroll.service';
import { AuthGuard } from '@modules/common/auth/auth.guard';
import { UserId } from '@modules/common/auth/decorators/user.decorator';
import { Roles } from '@modules/common/auth/decorators/roles.decorator';
import { SECTOR_PRIVILEGES } from '../../../constants/enums';
import {
  ZodValidationPipe,
  ZodQueryValidationPipe,
} from '@modules/common/pipes/zod-validation.pipe';
import { ReadRateLimit, WriteRateLimit } from '@modules/common/throttler/throttler.decorators';

// Import schemas and types
import {
  payrollCreateSchema,
  payrollUpdateSchema,
  payrollGetManyFormDataSchema,
  payrollQuerySchema,
  payrollBatchCreateSchema,
  payrollBatchUpdateSchema,
  payrollBatchDeleteSchema,
  payrollGenerateMonthSchema,
  payrollLiveCalculationSchema,
  discountCreateSchema,
  type PayrollCreateFormData,
  type PayrollUpdateFormData,
  type PayrollGetManyFormData,
  type PayrollQueryFormData,
  type PayrollBatchCreateFormData,
  type PayrollBatchUpdateFormData,
  type PayrollBatchDeleteFormData,
  type PayrollGenerateMonthParams,
  type PayrollLiveCalculationParams,
  type DiscountCreateFormData,
} from '../../../schemas/payroll';

@Controller('payroll')
@UseGuards(AuthGuard)
export class PayrollController {
  constructor(private readonly payrollService: PayrollService) {}

  // =====================
  // Regular CRUD Operations (like any other entity)
  // =====================

  /**
   * Get many payrolls - Standard entity list
   * Returns data from database, automatically includes live calculations for current period
   */
  @Get()
  @Roles(SECTOR_PRIVILEGES.HUMAN_RESOURCES, SECTOR_PRIVILEGES.ADMIN)
  @ReadRateLimit()
  async findMany(
    @Query(new ZodQueryValidationPipe(payrollGetManyFormDataSchema)) query: PayrollGetManyFormData,
    @UserId() userId: string,
  ) {
    // Use the new method that handles live calculations automatically
    return this.payrollService.getPayrollsWithLiveCalculation({
      where: query.where,
      include: query.include,
      page: query.page,
      limit: query.take,
    });
  }

  /**
   * Get payroll by ID - Standard entity retrieval
   * Supports both database UUIDs and composite live IDs (live-{userId}-{year}-{month})
   */
  @Get(':id')
  @Roles(SECTOR_PRIVILEGES.HUMAN_RESOURCES, SECTOR_PRIVILEGES.ADMIN)
  @ReadRateLimit()
  async findById(
    @Param('id') id: string,
    @Query(new ZodQueryValidationPipe(payrollQuerySchema)) query: PayrollQueryFormData,
    @UserId() userId: string,
  ) {
    const defaultInclude = {
      user: {
        include: {
          position: true,
          sector: true,
        },
      },
      bonus: {
        include: {
          tasks: true,
          bonusDiscounts: true,
        },
      },
      discounts: true,
    };

    const payroll = await this.payrollService.findByIdOrLive(id, defaultInclude);

    if (!payroll) {
      return {
        success: false,
        message: 'Folha de pagamento não encontrada.',
        data: null,
      };
    }

    return {
      success: true,
      message: 'Folha de pagamento obtida com sucesso.',
      data: payroll,
    };
  }

  /**
   * Update payroll - Standard entity update
   * Note: Payrolls are created by cronjob on the 25th at midnight, and can be edited
   * between the period end (25th) and payment date (5th).
   */
  @Put(':id')
  @Roles(SECTOR_PRIVILEGES.HUMAN_RESOURCES, SECTOR_PRIVILEGES.ADMIN)
  @WriteRateLimit()
  async update(
    @Param('id', ParseUUIDPipe) id: string,
    @Body(new ZodValidationPipe(payrollUpdateSchema)) data: PayrollUpdateFormData,
    @UserId() userId: string,
  ) {
    const result = await this.payrollService.update(id, data, userId);
    return {
      success: true,
      data: result,
      message: 'Folha de pagamento atualizada com sucesso.',
    };
  }

  /**
   * Delete payroll - Standard entity deletion
   * Note: Should be used with caution. Payrolls are generated by cronjob.
   */
  @Delete(':id')
  @Roles(SECTOR_PRIVILEGES.ADMIN)
  @WriteRateLimit()
  @HttpCode(HttpStatus.OK)
  async delete(@Param('id', ParseUUIDPipe) id: string, @UserId() userId: string) {
    await this.payrollService.delete(id, userId);
    return {
      success: true,
      message: 'Folha de pagamento excluída com sucesso.',
    };
  }

  // =====================
  // Batch Operations
  // =====================

  /**
   * Batch update payrolls
   */
  @Put('batch')
  @Roles(SECTOR_PRIVILEGES.HUMAN_RESOURCES, SECTOR_PRIVILEGES.ADMIN)
  @WriteRateLimit()
  async batchUpdate(
    @Body(new ZodValidationPipe(payrollBatchUpdateSchema)) data: PayrollBatchUpdateFormData,
    @UserId() userId: string,
  ) {
    const result = await this.payrollService.batchUpdate(
      data.updates!.map(u => ({ id: u.id!, data: u.data! })),
      userId,
    );
    return {
      success: true,
      data: result,
      message: `Atualização em lote: ${result.success.length} sucessos, ${result.failed.length} falhas.`,
    };
  }

  /**
   * Batch delete payrolls
   */
  @Delete('batch')
  @Roles(SECTOR_PRIVILEGES.ADMIN)
  @WriteRateLimit()
  @HttpCode(HttpStatus.OK)
  async batchDelete(
    @Body(new ZodValidationPipe(payrollBatchDeleteSchema)) data: PayrollBatchDeleteFormData,
    @UserId() userId: string,
  ) {
    const result = await this.payrollService.batchDelete(data.ids, userId);
    return {
      success: true,
      data: result,
      message: `Exclusão em lote: ${result.success.length} sucessos, ${result.failed.length} falhas.`,
    };
  }

  // =====================
  // Cronjob/System Endpoints
  // =====================

  /**
   * Generate payrolls for all active users for a specific month.
   * This is called by the cronjob on the 25th at midnight (00:00).
   * Creates payroll records for all active users with payroll numbers.
   */
  @Post('generate-month')
  @Roles(SECTOR_PRIVILEGES.ADMIN)
  @WriteRateLimit()
  @HttpCode(HttpStatus.CREATED)
  async generateMonthlyPayrolls(
    @Body(new ZodValidationPipe(payrollGenerateMonthSchema)) data: PayrollGenerateMonthParams,
    @UserId() userId: string,
  ) {
    // Validate month and year
    if (data.month < 1 || data.month > 12) {
      throw new Error('Mês deve estar entre 1 e 12');
    }
    if (data.year < 2020 || data.year > 2030) {
      throw new Error('Ano deve estar entre 2020 e 2030');
    }

    const result = await this.payrollService.generateForMonth(data.year, data.month, userId);
    return {
      success: true,
      data: result,
      message: `Folhas geradas: ${result.created} criadas, ${result.skipped} puladas.`,
    };
  }

  // =====================
  // Live Calculation Endpoints
  // =====================

  /**
   * Get live payroll calculation for the current user
   */
  @Get('live')
  @Roles(SECTOR_PRIVILEGES.HUMAN_RESOURCES, SECTOR_PRIVILEGES.ADMIN)
  @ReadRateLimit()
  async getLiveCalculations(
    @Query(new ZodQueryValidationPipe(payrollLiveCalculationSchema))
    query: PayrollLiveCalculationParams,
    @UserId() userId: string,
  ) {
    const now = new Date();
    return this.payrollService.calculateLivePayrollData(
      userId,
      now.getFullYear(),
      now.getMonth() + 1,
    );
  }

  /**
   * Get live payroll calculation for a specific user and period
   */
  @Get('live/:userId/:year/:month')
  @Roles(SECTOR_PRIVILEGES.HUMAN_RESOURCES, SECTOR_PRIVILEGES.ADMIN)
  @ReadRateLimit()
  async getLiveCalculation(
    @Param('userId', ParseUUIDPipe) targetUserId: string,
    @Param('year', ParseIntPipe) year: number,
    @Param('month', ParseIntPipe) month: number,
    @UserId() userId: string,
  ) {
    // Validate month and year
    if (month < 1 || month > 12) {
      throw new Error('Mês deve estar entre 1 e 12');
    }
    if (year < 2020 || year > 2030) {
      throw new Error('Ano deve estar entre 2020 e 2030');
    }

    return this.payrollService.calculateLivePayrollData(targetUserId, year, month);
  }

  // =====================
  // Filtering Endpoints
  // =====================

  /**
   * Get payrolls by user
   */
  @Get('user/:userId')
  @Roles(SECTOR_PRIVILEGES.HUMAN_RESOURCES, SECTOR_PRIVILEGES.ADMIN)
  @ReadRateLimit()
  async findByUser(
    @Param('userId', ParseUUIDPipe) targetUserId: string,
    @Query(new ZodQueryValidationPipe(payrollGetManyFormDataSchema)) query: PayrollGetManyFormData,
    @UserId() userId: string,
  ) {
    return this.payrollService.getPayrollsWithLiveCalculation({
      where: {
        ...query.where,
        userId: targetUserId,
      },
      include: query.include,
      page: query.page,
      limit: query.take,
    });
  }

  /**
   * Get payrolls by month
   */
  @Get('month/:year/:month')
  @Roles(SECTOR_PRIVILEGES.HUMAN_RESOURCES, SECTOR_PRIVILEGES.ADMIN)
  @ReadRateLimit()
  async findByMonth(
    @Param('year', ParseIntPipe) year: number,
    @Param('month', ParseIntPipe) month: number,
    @Query(new ZodQueryValidationPipe(payrollGetManyFormDataSchema)) query: PayrollGetManyFormData,
    @UserId() userId: string,
  ) {
    // Validate month and year
    if (month < 1 || month > 12) {
      throw new Error('Mês deve estar entre 1 e 12');
    }
    if (year < 2020 || year > 2030) {
      throw new Error('Ano deve estar entre 2020 e 2030');
    }

    return this.payrollService.getPayrollsWithLiveCalculation({
      where: {
        ...query.where,
        year,
        month,
      },
      include: query.include,
      page: query.page,
      limit: query.take,
    });
  }

  /**
   * Get payroll by user and month
   */
  @Get('user/:userId/month/:year/:month')
  @Roles(SECTOR_PRIVILEGES.HUMAN_RESOURCES, SECTOR_PRIVILEGES.ADMIN)
  @ReadRateLimit()
  async findByUserAndMonth(
    @Param('userId', ParseUUIDPipe) targetUserId: string,
    @Param('year', ParseIntPipe) year: number,
    @Param('month', ParseIntPipe) month: number,
    @Query(new ZodQueryValidationPipe(payrollQuerySchema)) query: PayrollQueryFormData,
    @UserId() userId: string,
  ) {
    // Validate month and year
    if (month < 1 || month > 12) {
      throw new Error('Mês deve estar entre 1 e 12');
    }
    if (year < 2020 || year > 2030) {
      throw new Error('Ano deve estar entre 2020 e 2030');
    }

    const defaultInclude = {
      user: {
        include: {
          position: true,
          sector: true,
        },
      },
      bonus: {
        include: {
          tasks: true,
          bonusDiscounts: true,
        },
      },
      discounts: true,
    };

    const payroll = await this.payrollService.findByUserAndMonth(
      targetUserId,
      year,
      month,
      defaultInclude,
    );

    if (!payroll) {
      return {
        success: false,
        message: 'Folha de pagamento não encontrada para este usuário e período.',
        data: null,
      };
    }

    return {
      success: true,
      message: 'Folha de pagamento obtida com sucesso.',
      data: payroll,
    };
  }

  // =====================
  // Personal Payroll Endpoints
  // =====================

  /**
   * Get current user's payroll for a specific period
   * Returns live calculation if not yet saved, or saved data if finalized
   */
  @Get('me/:year/:month')
  @ReadRateLimit()
  async getMyPayroll(
    @Param('year', ParseIntPipe) year: number,
    @Param('month', ParseIntPipe) month: number,
    @UserId() userId: string,
  ) {
    // Validate month and year
    if (month < 1 || month > 12) {
      throw new Error('Mês deve estar entre 1 e 12');
    }
    if (year < 2020 || year > 2030) {
      throw new Error('Ano deve estar entre 2020 e 2030');
    }

    const defaultInclude = {
      user: {
        include: {
          position: true,
          sector: true,
        },
      },
      bonus: {
        include: {
          tasks: true,
          bonusDiscounts: true,
        },
      },
      discounts: true,
    };

    const payroll = await this.payrollService.findByUserAndMonth(
      userId,
      year,
      month,
      defaultInclude,
    );

    // If no saved payroll, calculate live
    if (!payroll) {
      return this.payrollService.calculateLivePayrollData(userId, year, month);
    }

    return {
      success: true,
      message: 'Folha de pagamento obtida com sucesso.',
      data: payroll,
    };
  }

  // =====================
  // Bonus Simulation
  // =====================

  /**
   * Simulate bonuses for all users with optional filters (GET)
   */
  @Get('bonuses/simulate')
  @Roles(SECTOR_PRIVILEGES.HUMAN_RESOURCES, SECTOR_PRIVILEGES.ADMIN)
  @ReadRateLimit()
  async simulateBonusesGet(
    @Query('year', ParseIntPipe) year: number,
    @Query('month', ParseIntPipe) month: number,
    @UserId() userId: string,
    @Query('taskQuantity') taskQuantity?: string,
    @Query('sectorIds') sectorIds?: string,
    @Query('excludeUserIds') excludeUserIds?: string,
  ) {
    const params = {
      year,
      month,
      taskQuantity: taskQuantity ? parseInt(taskQuantity, 10) : undefined,
      sectorIds: sectorIds ? sectorIds.split(',') : undefined,
      excludeUserIds: excludeUserIds ? excludeUserIds.split(',') : undefined,
    };
    return this.payrollService.simulateBonuses(params);
  }

  /**
   * Simulate bonuses for all users with optional filters (POST)
   */
  @Post('simulate-bonuses')
  @Roles(SECTOR_PRIVILEGES.HUMAN_RESOURCES, SECTOR_PRIVILEGES.ADMIN)
  @ReadRateLimit()
  async simulateBonuses(
    @Body()
    params: {
      year: number;
      month: number;
      taskQuantity?: number;
      sectorIds?: string[];
      excludeUserIds?: string[];
    },
    @UserId() userId: string,
  ) {
    return this.payrollService.simulateBonuses(params);
  }
}
